# -*- coding: utf-8 -*-
"""Thesis-Adaptive-Regime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178vs_QIwYjnt3F0nBYID2ps--ByCVH_n

### Section 1: Basic Portfolio Methods for NIFTY Commodities Sector
"""

pip install yfinance numpy pandas seaborn matplotlib scikit-learn tensorflow keras pyportfolioopt hmmlearn joblib

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from pypfopt import EfficientFrontier, risk_models, expected_returns, HRPOpt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from google.colab import files

# Tickers "only" for NIFTY Commodities Sector are included here
tickers = [
    "RELIANCE.NS","ULTRACEMCO.NS","TATASTEEL.NS","NTPC.NS","JSWSTEEL.NS",
    "ONGC.NS","GRASIM.NS","HINDALCO.NS","COALINDIA.NS","UPL.NS"
]

data = yf.download(tickers,
                   start="2018-01-01",
                   end="2022-12-31",
                   progress=False,
                   auto_adjust=False
                  )

prices = data["Close"]
prices = prices.dropna()
print(prices.head())

train = prices.loc["2018-01-01":"2021-12-31"]
test  = prices.loc["2022-01-01":"2022-12-31"]

train_ret = train.pct_change().dropna()
test_ret  = test.pct_change().dropna()

# Method Monte Carlo Weights Simulation Method
mu = train_ret.mean() * 250          # annualised mean return vector
S  = train_ret.cov()  * 250          # annualised covariance matrix


N = 10_000
all_w = np.random.dirichlet(np.ones(len(train_ret.columns)), N)

ret_arr = all_w @ mu.values
vol_arr = np.sqrt(np.einsum('ij,jk,ik->i', all_w, S.values, all_w))
sharpe  = ret_arr / vol_arr

best_idx = np.argmax(sharpe)
w_mvp    = dict(zip(train_ret.columns, all_w[best_idx]))

print(pd.Series(w_mvp).round(4))

# Method to build Hierarchical Based Portfolio
from scipy.cluster.hierarchy import linkage
from scipy.spatial.distance import squareform
from pypfopt import HRPOpt
from pypfopt import risk_models


corr = train_ret.corr()
corr = corr.clip(-1, 1).fillna(0)
dist = np.sqrt(0.5 * (1 - corr))
condensed_dist = squareform(dist.values, checks=False)

# Ward linkage
ward_linkage = linkage(condensed_dist, method="ward")

hrp = HRPOpt(train_ret)
hrp._linkage = ward_linkage
w_hrp = hrp.optimize()

print(pd.Series(w_hrp).round(4))

# Method to build Autoencoder based portfolio
scaler = MinMaxScaler()
train_scaled = scaler.fit_transform(train)

n_assets = train_scaled.shape[1]

ae = Sequential([
    Dense(5,  activation="relu",   input_shape=(n_assets,)),
    Dense(n_assets, activation="linear")
])

ae.compile(optimizer="adam", loss="mse")
ae.fit(train_scaled, train_scaled, epochs=1000,
       batch_size=10, verbose=0
       )

raw_scores = np.abs(ae.predict(train_scaled[-1][None, :], verbose=0)[0])
w_enc = dict(zip(tickers, raw_scores / raw_scores.sum()))

pd.Series(w_enc).round(4).sort_values(ascending=False)

weights_df = (
    pd.DataFrame(
        {
            "MVP"        : w_mvp,
            "HRP"        : w_hrp,
            "Autoencoder": w_enc,
        }
    )
    .reindex(tickers)
    .fillna(0)
    .round(4)
)

pd.options.display.float_format = "{:.4f}".format
print("\nPortfolio Weights Allocation")
print(weights_df)

for method, w in [("MVP", w_mvp), ("HRP", w_hrp), ("Autoencoder", w_enc)]:
    plt.figure(figsize=(5,5))
    plt.pie(list(w.values()), labels=list(w.keys()), autopct="%1.1f%%", startangle=140)
    plt.title(f"NIFTY Commodities Weights — {method}")
    plt.axis("equal")
    plt.show()

def perf(weights, returns, *, days_per_year: int = 250, rf: float = 0.0):

    w = pd.Series(weights, dtype=float).reindex(returns.columns).fillna(0)

    # daily portfolio returns
    port = returns.dot(w)

    # cumulative wealth series (compound growth)
    wealth = (1 + port).cumprod()

    total_ret = wealth.iloc[-1] - 1.0
    n_days    = wealth.size
    cagr      = (1 + total_ret)**(days_per_year / n_days) - 1
    ann_vol   = port.std(ddof=1) * np.sqrt(days_per_year)
    sharpe    = np.nan if ann_vol == 0 else (cagr - rf) / ann_vol


    return cagr*100, ann_vol*100, sharpe, wealth - 1

methods   = {"MVP": w_mvp, "HRP": w_hrp, "Autoencoder": w_enc}


perf_data = {}
cum_train = pd.DataFrame(index=train_ret.index)
cum_test  = pd.DataFrame(index=test_ret.index)


for name, w in methods.items():
    tr, tv, ts, cum_tr = perf(w, train_ret)
    er, ev, es, cum_te = perf(w, test_ret)

    perf_data[name] = [tr, tv, ts, er, ev, es]

    cum_train[name] = cum_tr
    cum_test[name]  = cum_te


print(pd.DataFrame(perf_data,
                   index=["TR","TV","TS","ER","EV","ES"]).T.round(4))

from collections import OrderedDict


row_order    = ["MVP", "HRP", "Autoencoder"]
metric_names = OrderedDict([
    ("TR", "Annual Return (%)"),
    ("TV", "Annual Volatility (%)"),
    ("TS", "Sharpe Ratio"),
])


tmp = (
    pd.DataFrame.from_dict(
        perf_data, orient="index",
        columns=["TR", "TV", "TS", "ER", "EV", "ES"]
    )
    .loc[row_order]
)

cols = pd.MultiIndex.from_product(
    [
        ["Training (2018-2021)", "Test (2022)"],
        metric_names.values()
    ]
)

perf_df = pd.DataFrame(index=row_order, columns=cols, dtype=float)

for code, nice in metric_names.items():
    perf_df[("Training (2018-2021)", nice)] = tmp[code]
    perf_df[("Test (2022)",           nice)] = tmp["E" + code[1]]

perf_df = perf_df.round(2)

print("\n=== Portfolio Performance ===")
print(perf_df)

cum_train = pd.DataFrame({
    name: perf(w, train_ret)[3]
    for name, w in methods.items()
})
cum_test = pd.DataFrame({
    name: perf(w, test_ret)[3]
    for name, w in methods.items()
})

import matplotlib.pyplot as plt
import matplotlib.dates as mdates


plt.figure(figsize=(9,6))
for method in cum_train.columns:
    plt.plot(cum_train.index, cum_train[method], label=method, linewidth=2)

plt.title("Figure 6: Cumulative Daily Returns — Training Period (2018–2021)", fontsize=14)
plt.xlabel("Date", fontsize=12)
plt.ylabel("Cumulative Return", fontsize=12)
plt.legend(fontsize=12)
plt.grid(True, linestyle="--", alpha=0.5)

ax = plt.gca()
ax.xaxis.set_major_locator(mdates.MonthLocator(interval=6))
ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m"))

plt.tight_layout()
plt.show()

plt.figure(figsize=(9,6))
for method in cum_test.columns:
    plt.plot(cum_test.index, cum_test[method], label=method, linewidth=2)

plt.title("Figure 7: Cumulative Daily Returns — Test Period (2022)", fontsize=14)
plt.xlabel("Date", fontsize=12)
plt.ylabel("Cumulative Return", fontsize=12)
plt.legend(fontsize=12)
plt.grid(True, linestyle="--", alpha=0.5)

ax = plt.gca()
ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m"))

plt.tight_layout()
plt.show()