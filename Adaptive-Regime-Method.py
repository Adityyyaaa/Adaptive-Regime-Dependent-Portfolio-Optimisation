# -*- coding: utf-8 -*-
"""Final-Compiled-Adaptive-Regime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qE2bk49hhTkb0qZYSbTsBWdPQjVIOEKR
"""

pip install yfinance numpy pandas seaborn matplotlib scikit-learn tensorflow keras pyportfolioopt hmmlearn joblib

import time, warnings, pathlib, joblib
import numpy as np, pandas as pd, yfinance as yf
from datetime import timedelta
from hmmlearn.hmm import GaussianHMM
from pypfopt import expected_returns as er
from pypfopt.black_litterman import BlackLittermanModel
from pypfopt.risk_models import CovarianceShrinkage
from pypfopt.efficient_frontier import EfficientCVaR
from pypfopt.objective_functions import L2_reg
import pandas_datareader.data as web
import matplotlib.pyplot as plt

plt.rcParams["figure.dpi"] = 110

SECTORS = {
    "Commodities": [
        "RELIANCE.NS","ULTRACEMCO.NS","TATASTEEL.NS","NTPC.NS","JSWSTEEL.NS",
        "ONGC.NS","GRASIM.NS","HINDALCO.NS","COALINDIA.NS","UPL.NS"],
    "Energy": [
        "RELIANCE.NS","NTPC.NS","POWERGRID.NS","ONGC.NS","TATAPOWER.NS",
        "BPCL.NS","IOC.NS","GAIL.NS","ADANITRANS.NS","ADANIGREEN.NS"],
    "Manufacturing": [
        "SUNPHARMA.NS","RELIANCE.NS","M&M.NS","TATASTEEL.NS","MARUTI.NS",
        "JSWSTEEL.NS","HINDALCO.NS","TATAMOTORS.NS","DRREDDY.NS","CIPLA.NS"],
    "Services": [
        "HDFCBANK.NS","ICICIBANK.NS","INFY.NS","HDFC.NS","TCS.NS",
        "KOTAKBANK.NS","AXISBANK.NS","SBIN.NS","BHARTIARTL.NS","BAJFINANCE.NS"],
    "MNC": [
        "MARUTI.NS","HINDUNILVR.NS","NESTLEIND.NS","BRITANNIA.NS","VEDL.NS",
        "SIEMENS.NS","AMBUJACEM.NS","MCDOWELL-N.NS","CUMMINSIND.NS","ASHOKLEY.NS"],
    "Transportation": [
        "M&M.NS","MARUTI.NS","TATAMOTORS.NS","ADANIPORTS.NS","EICHERMOT.NS",
        "BAJAJ-AUTO.NS","HEROMOTOCO.NS","TIINDIA.NS","TVSMOTOR.NS","ASHOKLEY.NS"],
    "Infrastructure": [
        "RELIANCE.NS","LT.NS","BHARTIARTL.NS","ULTRACEMCO.NS","NTPC.NS",
        "POWERGRID.NS","ONGC.NS","GRASIM.NS","APOLLOHOSP.NS","ADANIPORTS.NS"],
    "Housing": [
        "LT.NS","ASIANPAINT.NS","HDFCBANK.NS","ICICIBANK.NS","ULTRACEMCO.NS",
        "TATASTEEL.NS","NTPC.NS","HDFC.NS","JSWSTEEL.NS","GRASIM.NS"],
    "Consumption": [
        "ITC.NS","HINDUNILVR.NS","BHARTIARTL.NS","ASIANPAINT.NS","M&M.NS",
        "MARUTI.NS","TITAN.NS","NESTLEIND.NS","BRITANNIA.NS","DMART.NS"],
    "ESG": [
        "INFY.NS","TCS.NS","HDFC.NS","HCLTECH.NS","ICICIBANK.NS",
        "BHARTIARTL.NS","TECHM.NS","KOTAKBANK.NS","BAJFINANCE.NS","TITAN.NS"],
}

INDEX_TKR   = "^NSE"
START_FETCH = "2017-06-01"
END_FETCH   = "2023-01-10"

TRAIN_START, TRAIN_END = "2018-01-01", "2021-12-31"
TEST_START,  TEST_END  = "2022-01-01", "2022-12-31"

LOOKBACK     = 504            # 2 trading-years
TRADING_DAYS = 250
CACHE        = pathlib.Path("data_cache.pkl")

CHUNK, MAX_RETRY, BASE_PAUSE = 4, 7, 10

def _download_chunk(tickers):
    pause = BASE_PAUSE
    for attempt in range(1, MAX_RETRY+1):
        try:
            df = yf.download(tickers, START_FETCH, END_FETCH,
                             auto_adjust=False, progress=False,
                             group_by="column", threads=True)["Close"]
            if df.dropna(how="all").empty:
                raise ValueError("all-NaN frame")
            return df
        except Exception as e:
            warnings.warn(f"Yahoo rate-limit ({e}) → retry {attempt}/{MAX_RETRY} in {pause}s")
            time.sleep(pause); pause *= 2
    raise RuntimeError(f"Yahoo failed after {MAX_RETRY} retries: {tickers}")

def load_prices():
    if CACHE.exists():
        return joblib.load(CACHE)

    tkrs_all = sorted({*{t for v in SECTORS.values() for t in v}, INDEX_TKR})
    frames = []
    for i in range(0, len(tkrs_all), CHUNK):
        frames.append(_download_chunk(tkrs_all[i:i+CHUNK]))
    raw = pd.concat(frames, axis=1).reindex(columns=tkrs_all)
    joblib.dump(raw, CACHE)
    return raw

raw_prices = load_prices()

# --------------------------------------------------------------
# 2.  Build a market-proxy series (^NSEI › NIFTYBEES › synthetic)
# --------------------------------------------------------------
def build_market_series():
    def slow_yahoo(tkr):
        pause = 10
        for _ in range(6):
            try:
                d = yf.download(tkr, START_FETCH, END_FETCH,
                                auto_adjust=False, progress=False)
                for col in ["Close","Adj Close"]:
                    if col in d and not d[col].dropna().empty:
                        return d[col]
            except Exception: pass
            time.sleep(pause); pause *= 2
        return pd.Series(dtype=float)

    for t in ["^NSEI","NIFTYBEES.NS"]:
        s = slow_yahoo(t)
        if not s.empty: return s

    try:                      # Stooq fallback
        s = web.DataReader("^NSEI", "stooq", START_FETCH, END_FETCH)["Close"].sort_index()
        if not s.dropna().empty: return s
    except Exception: pass

    # synthetic equal-weight basket
    print("Building synthetic index from sector stocks")
    return raw_prices.dropna(how="all", axis=1).mean(axis=1)

index_px = build_market_series()
raw_prices[INDEX_TKR] = index_px

# ensure Series, ensure .name
if isinstance(index_px, pd.DataFrame):
    index_px = index_px.iloc[:,0]
if index_px.name is None:
    index_px.name = "synthetic"

# --------------------------------------------------------------
# 3.  Gaussian-HMM fit  (4-state BIC search)
# --------------------------------------------------------------
def best_hmm(series, k_max=4, n_inits=5, seed=42):
    X = ((series - series.mean())/series.std()).dropna().values.reshape(-1,1)
    rng = np.random.RandomState(seed); best_bic = np.inf; best = None
    for k in range(2, k_max+1):
        for _ in range(n_inits):
            hmm = GaussianHMM(k,"diag",n_iter=1000,tol=1e-4,
                              random_state=rng.randint(10000)).fit(X)
            bic = -2*hmm.score(X) + k*np.log(len(X))
            if bic < best_bic: best_bic, best = bic, hmm
    return best

hmm_model = best_hmm(index_px.pct_change().dropna())
hidden_state = pd.Series(
    hmm_model.predict(index_px.pct_change().dropna().values.reshape(-1,1)),
    index=index_px.index[1:], name="state")

# --------------------------------------------------------------
# 4.  Regime-specific optimisers
# --------------------------------------------------------------
def deterministic_mvp(px, step=0.05):
    r  = px.pct_change().dropna()
    mu, S = r.mean()*TRADING_DAYS, r.cov()*TRADING_DAYS
    best_sr, best_w = -np.inf, None
    grid = np.arange(0,1+1e-9, step)
    from itertools import product
    for w in product(grid, repeat=len(mu)):
        if abs(sum(w)-1) > 1e-8: continue
        w = np.asarray(w)
        ret = w @ mu.values
        vol = np.sqrt(w @ S.values @ w)
        sr  = ret/vol if vol else -np.inf
        if sr > best_sr: best_sr, best_w = sr, w
    return pd.Series(best_w, index=mu.index)

def bl_cvar_portfolio(px):
    r = px.pct_change().dropna()
    S = CovarianceShrinkage(px).ledoit_wolf()*TRADING_DAYS

    # tell PyPortfolioOpt we have *no* discretionary views
    bl = BlackLittermanModel(
        S,
        pi=er.capm_return(px),
        tau=0.05,
        absolute_views={},          # ← prevents TypeError
    )

    ef = EfficientCVaR(
        expected_returns=r.mean()*TRADING_DAYS,
        returns=r,
        beta=0.95,
        solver="ECOS",
    )
    ef.expected_returns, ef.cov_matrix = bl.bl_returns(), S
    ef.add_objective(L2_reg, gamma=1e-4)
    ef.min_cvar()
    return pd.Series(ef.clean_weights())

def cvar_portfolio(px):
    r = px.pct_change().dropna()
    ef = EfficientCVaR(expected_returns=r.mean()*TRADING_DAYS,
                       returns=r, beta=0.95, solver="ECOS")
    ef.min_cvar()
    return pd.Series(ef.clean_weights())

REGIME_OPT = {0: deterministic_mvp, 1: bl_cvar_portfolio, 2: cvar_portfolio}

def adaptive_curve(tickers, start, end):
    px = (raw_prices.loc[:end, tickers]
          .dropna(axis=1, how="all"))
    if px.empty:
        raise ValueError("No usable price series")
    px = px.ffill(limit=5)
    ret = px.pct_change().dropna(how="all")
    if len(ret) <= LOOKBACK:
        raise ValueError("Need more history")

    states = hidden_state.loc[:end]

    month_ends = (ret.index.to_series()
                  .groupby([ret.index.year, ret.index.month]).last())
    threshold = ret.index[LOOKBACK]
    dates = pd.DatetimeIndex(month_ends[month_ends >= threshold].values)

    curves = []
    for i, d in enumerate(dates):
        win    = px.loc[:d].iloc[-LOOKBACK:]
        regime = int(states.loc[:d].iloc[-1])
        w      = REGIME_OPT[regime](win)
        s = d + timedelta(days=1)
        e = dates[i+1] if i+1 < len(dates) else ret.index[-1]
        curves.append(ret.loc[s:e].dot(w))

    return (1 + pd.concat(curves)).cumprod().loc[start:end]

# --------------------------------------------------------------
# 6.  Metrics helper
# --------------------------------------------------------------
def perf(curve, days=TRADING_DAYS):
    r = curve.pct_change().dropna()
    vol  = r.std()*np.sqrt(days)
    cagr = (curve.iloc[-1]/curve.iloc[0])**(days/len(curve)) - 1
    return pd.Series({"Annual Return": cagr,
                      "Annual Vol": vol,
                      "Sharpe Ratio": cagr/vol})

# ==============================================================
#  7.  Run strategy for ALL sectors  ➜  tables + bar-plots
# ==============================================================

train_tbl, test_tbl = {}, {}
for sec, tkrs in SECTORS.items():
    print(f"⏳  {sec:14s}", end="  ")
    train_tbl[sec] = perf(adaptive_curve(tkrs, TRAIN_START, TRAIN_END))
    test_tbl [sec] = perf(adaptive_curve(tkrs, TEST_START,  TEST_END))
    print("✓")

train_df = pd.DataFrame(train_tbl).T
test_df  = pd.DataFrame(test_tbl ).T
fmt = {"Annual Return":"{:.2%}", "Annual Vol":"{:.2%}", "Sharpe Ratio":"{:.4f}"}

from IPython.display import display
display(train_df.style.format(fmt).set_caption("Adaptive-Regime  –  Training  (2018-2021)"))
display(test_df .style.format(fmt).set_caption("Adaptive-Regime  –  Testing   (2022)"))

# ---------- bar-plots -----------------------------------------
def plot_metric(metric, ylabel):
    plt.figure(figsize=(11,4))
    x = np.arange(len(SECTORS)); w = 0.35
    plt.bar(x-w/2, train_df[metric], w, label="Training")
    plt.bar(x+w/2, test_df [metric], w, label="Testing")
    plt.xticks(x, SECTORS.keys(), rotation=45, ha="right")
    plt.ylabel(ylabel)
    plt.title(f"{metric} – Adaptive-Regime (10 sectors)")
    plt.grid(axis="y", alpha=.3)
    if "Return" in metric or "Vol" in metric:
        plt.ylim(bottom=0); plt.gca().yaxis.set_major_formatter(lambda v,_:f"{v:.0%}")
    plt.legend(); plt.tight_layout(); plt.show()

plot_metric("Annual Return", "Annual Return")
plot_metric("Annual Vol",   "Annualised Volatility")
plot_metric("Sharpe Ratio", "Sharpe Ratio")